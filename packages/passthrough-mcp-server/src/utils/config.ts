/**
 * Configuration Management Module
 *
 * Handles loading and defining the configuration for both the MCP server
 * and the target client connection. Loads settings from environment variables
 * and command line arguments.
 */

import { existsSync, readFileSync } from "node:fs";
import { resolve } from "node:path";
import * as process from "node:process";
import type { Hook } from "@civic/hook-common";
import { configureLoggerForStdio, logger } from "./logger.js";

export type TransportType = "stdio" | "sse" | "httpStream";

// Base configuration with discriminated union based on transport type
export type BaseConfig =
  | {
      transportType: "stdio";
      // Port is not required for stdio
    }
  | {
      transportType: "sse" | "httpStream";
      port: number;
    };

export type TargetConfig =
  | {
      transportType: "sse" | "httpStream";
      url: string;
    }
  | {
      transportType: "stdio";
      command: string;
    };

export interface RemoteHookConfig {
  url: string;
  name?: string; // Optional name for the hook
}

export type HookDefinition = RemoteHookConfig | Hook;

// MCPHooksConfig matches the format generated by the builder
export interface MCPHooksConfig {
  target: {
    mode: "local" | "remote";
    command?: string;
    url?: string;
  };
  proxy: {
    port: number;
    transport: "stdio" | "sse" | "httpStream";
  };
  hooks: Array<{
    name?: string;
    url?: string;
    config?: Record<string, unknown>;
  }>;
}

// Built-in hook name mapping to their default ports
// For now, we'll use remote URLs until the hooks export their classes
const BUILTIN_HOOKS: Record<string, string> = {
  SimpleLogHook: "http://localhost:33006",
  AuditHook: "http://localhost:33004",
  GuardrailHook: "http://localhost:33007",
  CustomDescriptionHook: "http://localhost:33008",
  ExplainHook: "http://localhost:33009",
};

export type Config = BaseConfig & {
  target: TargetConfig;
  hooks?: HookDefinition[];
  serverInfo?: {
    name: string;
    version: `${number}.${number}.${number}`;
  };
  clientInfo?: {
    name: string;
    version: string;
  };
};

/**
 * Parse server transport type from command line arguments
 */
export function parseServerTransport(args: string[]): TransportType {
  if (args.includes("--stdio")) return "stdio";
  if (args.includes("--sse")) return "sse";
  return "httpStream";
}

/**
 * Parse client transport type from environment
 */
export function parseClientTransport(
  env: NodeJS.ProcessEnv,
): "sse" | "httpStream" {
  return env.TARGET_SERVER_TRANSPORT === "sse" ? "sse" : "httpStream";
}

/**
 * Parse hook URLs from environment variable
 */
export function parseHookUrls(hooksEnv?: string): string[] {
  if (!hooksEnv) return [];
  return hooksEnv
    .split(",")
    .map((url) => url.trim())
    .filter((url) => url.length > 0);
}

/**
 * Convert hook URLs to hook configurations
 */
export function createHookConfigs(urls: string[]): RemoteHookConfig[] {
  return urls.map((url) => {
    try {
      const urlObj = new URL(url);
      return {
        url,
        name: urlObj.hostname,
      };
    } catch {
      // If URL parsing fails, use the whole URL as name
      return {
        url,
        name: url,
      };
    }
  });
}

/**
 * Load config from mcphooks.config.json file
 */
export function loadConfigFromFile(filePath: string): MCPHooksConfig | null {
  try {
    const absolutePath = resolve(filePath);
    if (!existsSync(absolutePath)) {
      return null;
    }
    const content = readFileSync(absolutePath, "utf-8");
    return JSON.parse(content) as MCPHooksConfig;
  } catch (error) {
    logger.error(`Failed to load config from ${filePath}: ${error}`);
    return null;
  }
}

/**
 * Get the URL for a built-in hook
 */
export function getBuiltinHookUrl(hookName: string): string | null {
  return BUILTIN_HOOKS[hookName] || null;
}

/**
 * Convert MCPHooksConfig to Config
 */
export function convertMCPHooksConfig(mcpConfig: MCPHooksConfig): Config {
  // Convert target config
  let targetConfig: TargetConfig;
  if (mcpConfig.target.mode === "local" && mcpConfig.target.command) {
    targetConfig = {
      transportType: "stdio",
      command: mcpConfig.target.command,
    };
  } else if (mcpConfig.target.url) {
    targetConfig = {
      transportType: "httpStream", // Default to httpStream
      url: mcpConfig.target.url,
    };
  } else {
    throw new Error("Invalid target configuration in mcphooks.config.json");
  }

  // Convert hooks
  const hooks: HookDefinition[] = mcpConfig.hooks.map((hook) => {
    if (hook.url) {
      return { url: hook.url, name: hook.name } as RemoteHookConfig;
    }
    if (hook.name) {
      // Get URL for built-in hook
      const builtinUrl = getBuiltinHookUrl(hook.name);
      if (builtinUrl) {
        return { url: builtinUrl, name: hook.name } as RemoteHookConfig;
      }
      throw new Error(`Unknown built-in hook: ${hook.name}`);
    }
    throw new Error(`Invalid hook configuration: ${JSON.stringify(hook)}`);
  });

  // Build final config
  const baseConfig: BaseConfig =
    mcpConfig.proxy.transport === "stdio"
      ? { transportType: "stdio" }
      : {
          transportType: mcpConfig.proxy.transport as "sse" | "httpStream",
          port: mcpConfig.proxy.port,
        };

  return {
    ...baseConfig,
    target: targetConfig,
    hooks: hooks.length > 0 ? hooks : undefined,
  };
}

/**
 * Load configuration from environment and command line
 */
export function loadConfig(): Config {
  // Check for CONFIG_FILE first
  const configFile = process.env.CONFIG_FILE;
  if (configFile) {
    const fileConfig = loadConfigFromFile(configFile);
    if (fileConfig) {
      logger.info(`Loading configuration from ${configFile}`);
      const config = convertMCPHooksConfig(fileConfig);

      // Configure logger for stdio mode
      if (config.transportType === "stdio") {
        configureLoggerForStdio();
      }

      return config;
    }
  }

  // Fall back to environment variable configuration
  // Server configuration
  const transportType = parseServerTransport(process.argv);

  // Configure logger for stdio mode to avoid interfering with stdout
  if (transportType === "stdio") {
    configureLoggerForStdio();
  }

  // Check for TARGET_SERVER_COMMAND for local mode
  const targetCommand = process.env.TARGET_SERVER_COMMAND;
  let targetConfig: TargetConfig;

  if (targetCommand) {
    targetConfig = {
      transportType: "stdio",
      command: targetCommand,
    };
  } else {
    // Target configuration for remote mode
    const targetUrl = process.env.TARGET_SERVER_URL || "http://localhost:33000";
    const targetTransport = parseClientTransport(process.env);
    targetConfig = {
      transportType: targetTransport,
      url: targetUrl,
    };
  }

  // Hooks configuration
  const hookUrls = parseHookUrls(process.env.HOOKS);

  // Build config based on transport type
  let config: Config;

  if (transportType === "stdio") {
    config = {
      transportType: "stdio",
      target: targetConfig,
    };
  } else {
    const port = process.env.PORT ? Number.parseInt(process.env.PORT) : 34000;
    config = {
      transportType,
      port,
      target: targetConfig,
    };
  }

  // Add hooks config if URLs are provided
  if (hookUrls.length > 0) {
    config.hooks = createHookConfigs(hookUrls);

    logger.info(`${hookUrls.length} tRPC hooks enabled:`);
    hookUrls.forEach((url, index) => {
      logger.info(`  ${index + 1}. ${url}`);
    });
  }

  return config;
}
